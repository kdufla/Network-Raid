# Network Raid

### გიორგი გველესიანი
<br>

English:<br>
(temporary short version)<br>
This project is implementation of distibuted network filesystem using raid 1 or raid 5 (not working, for now) for linux (tested on ubuntu 14.04, 16.04 and 18.04). program need libraries pkg-config, libfuse-dev, libssl-dev and attr and compiles with make. program needs config file (sample is included). client runs with `./client CONFIG_PATH` and server runs with `./server IP PORT DISK_PATH`

## ზოგადი იდეა
პროექტი არის დისტრიბუციული ფაილური სისტემის იმპლემენტაცია ლინუქსის API-ს გამოყენებით. კლიენტს ეძლევა შესაძლებლობა, თავის სისტემაში რამდენიმე დირექტორიაზე დაამაუნთოს სერვერები. ამის პლიუსი არის დიდ დრაივზე წვდომა ნებისმიერი ადგილიდან და უსაფრთხოება, რადგან სერვერები კლიენტის მიერ არჩეული რეიდის მიხედვით იცავენ დატას მთლიანობას. სამაგიეროდ დრაივის ჯიბით ტარებისგან განსხვავებით უინტერნეტოდ სერვერთან წვდომა ვერ მოხდება და იდეალური ინტერნეტის შემთხვევაშიც იქნება ოვერჰედი.

## გამოყენება
პროექტის გაშვებამდე საჭიროა რამდნიმე ბიბლიოთეკის გადმოწერა Advanced Package Tool-ის გამოყენებით:
* libssl-dev
* pkg-config 
* libfuse-dev
* attr

ბრძანებით: `sudo apt install pkg-config libfuse-dev libssl-dev attr`

საჭირო ბიბლიოთეკების დაყენების შემდეგ პროგრამა კომპილირდება `make` ბრძანებით, სუფთავდება `make clean`-ით (და ფაილში კონფიგურაციის ფაილის მისამართის შეცვლის შემდეგ მაუნთდება `make m` -ით). პროგრამას სჭირდება კონფიგურაციის ფაილი, რომელშიც გაწერილი იქნება ფუნქციონირებისთვის საჭირო ინფორმაცია (კლიენტის მოთხოვნები)

### კლიენტის გაშვება (დამაუნთება)
`./client CONFIG_PATH`

### სერვერის გაშვება 
`./server IP PORT DISK_PATH`

## კომფორტის შემქმნელი feature-ები
### კონფიგურაცია
კონფიგურაციის ფაილს პარსავს პარსერ პროგრამა და აბრუნებს სტრუქტურას `storage`. კონფიგურაციის ფაილი აუცილებელია, პირველ ოთხ ხაზზე შეიცავდეს errorlog, cache_size, cache_replacment და timeout ვლეებს. ხაზი დასრულებულად ჩაითბლება მხოლოს მაშინ, როცა ეწერება `\n`. ხაზის ბოლოს სფეისები ჩსითვლებიან ვალიდურ სიმბოლოებად და პროგრამა ისე არ მოიქცევა, როგორც კლიენტს უნდა. ამ ოთხი ხაზის შემდეგ უნდა იყოს ცარიელი ხაზით გამოყოფილი ხუთი ხაზისგან შემდგარი საწყობის (storage) ან საწყობების (ერთმანეთისგან ცარიელი ხაზით გამოყოფილი) ინფორმაცია.  თანმიმდევრობის არევის, ზედმეტი სფეისების და ნიუ ლაინების შემთხვევაში პროგრამა არ იმუშავებს.

### ლოგირება
ლოგირება ხდება ყველა სისტემური ბრძანების, გარდა `getattr`-ისა, რადგან ის ძალიან ბევრჯერ გამოიძახება და ლოგის წაკითხვას ართულებს. გამზადებული ბრძანება `client.c` ფაილში არის დაკომენტარებული და საჭიროების შემთხვევაში შეიძლება ამის ჩართვაც, მაგრამ არ ვურჩევ არავის. სისტემური ბრძანებების გარდა ხდება ისეთი მნისვნელოვანი მნისვნელოვანი მომენტების ლოგირება, როგორიცაა სერვერთან კავშირის სთეითი, დაზიანებული ფაილის აღმოჩენა და etc.

## რეიდ 1
იმპლემენტირებული სისქოლები არიან open, read, write, release, rename, unlink, rmdir, mkdir, readdir, getattr, mknod, utimens, truncate.

სერვერებს პირობითად ჰქვიათ primary და secondary (შემდგომ მთავარი და დამხმარე). მთავარი სერვერი მუშაობს ყველა სისტემური ბრძანების დროს, ხოლო დამხმარე (ოფტიმალურობისთვის) მხოლოდ მაშინ, როცა მისი სთეითის შეცვლაა საჭირო. ინფორმაციის წამოღება დამხმარე სერვერიდან არ ხდება. ჩაწერა ხდება `stable storage` მექანიზმით. დაზიანებული ან არარსებული ფაილის აღმოჩენა ხდება `open` -ის დროს. გახსნის დროს მოწმდება ჰეშები (SHA1, რომელიც შექმნის და ჩაწერის დროს გამოითვლება და ინახება). თუ ჰეში ფაილის კონტენტს არ დაემთხვევა, სერვერი აგზავნის HASH_ERROR-ს და კლიენტი მეორე სერვერიდან უგზავნის დატას. თუ ფაილი არ არსებობს (სერვერი დროებით გათიშული იყო როცა შეიქმნა) სერვერზე ხდება ერორი და დაბრუნებული ერნო არის ENOENT, ამ შემთხვევაშიც კლიენტი უკოპირებს მეორე სერვერიდან. თუ ორივე ფაილი უშეცდომოდ გაიხსნა, მაგრამ დაბრუნებული ჰეშები არ ემთხვევა განახლების დრო რომელსაც მეტი აქვს იმ ფაილს ვიღებთ სწორ ფაილად და მეორეს ვანაცვლებთ. ეს აგვარებს როგორც stable storage ექანიზმით გათვალისწინებულ პრობლემას, ასევე სერვერი თუ საერთოდ გათიშული იყო აფდეითის დროს და ვერ მოხდა ფაილის კონტენტის განახლება. 

## რეიდ 5
note: ჯერ არ ეშვება, რადგან fuse ვერ მაუნთდება.<br>
იმპლემენტირებულია იგივე სისქოლები. ოთხი სისქოლის გარდა სხვები ყველასთვის რაღაცის გაგზავნა და პასუხის მიღებაა. რეიდ 5-ის რეიდ 5-ობა რეალურად ჩანს ოთხ სისქოლში. getattr იღებს struct stat-ებს და მათ ზომებს აჯამებს, რადგან ფაილი განაწილებულია სხვადასხვა სერვერებზე. truncate მიღებულ ზომას ანაწილებს სერვერებზე, რადგან, მაგალითად 5 სერვერის არსებობის შემთხვევაში პირდაპირ გაგზავნილი ზომა იმაზე 4ჯერ (ერთი ფერითი) დიდ ადგილს გამოყოფდა, ვიდრე საჭიროა, რადგან დატა გადანაწილებულია. write გადაუყვება ბაფერს და ბლოკ-ბლოკად აგზავნის სხვადასხვა სერვერზე. ბოლოს გადაუყვება და ყველა სტრაიპს, რომელსაც შეეხო გაუახლებს ფერითის შესაბამის სერვერზე. read ზუსტად write-ს ლოგიკით გადაუყვება და ბლოკ-ბლოკად მოაქვს დატა სერვერებიდან. ბლოკის ზომა ახლა არის 4096, რადგან დისკზე ბლოკის ზომა იგივეა და ნაკლების გამოყოფის მოთხოვნით მაინც მთლიანი ბლოკი გამოიყოფა. ერორს როცა გავასწორებ მერე დავუთმობ მეტ დროს ბლოკის ზომაზე ფიქრს. 

## timeout and hotswap
### timeout
 სერვერთან კავშირი მოწმდება სერვერზე მარტივი შეტყობინების გაგზავნით (ping-ის გამარტივებული ვარიანტი). სერვერს ეგზავნება სტანდარტული სისქოლის ჰედერი და უკან აბრუნებს 1-ს. თუ ქონექშენი გაფუჭებულია, კლიენტს არაფერი დაუბრუნდება და სერვერს დაკარგულად გამოაცხადებს. თუ ეს მთავარი სერვერი იყო, მაშინ დამხმარე გამოცხადდება მთავარ სერვერად. პერიოდულად ისევ მოწმდება სერვერთან კავშირის აღდგენა თუ არის შესაძლებელი. კონფიგში მოცემული დროის გასვლის შემდეგ თუ ვერ მოხდა დაკავშირდება, იწყება hotswap

 ### hotswap
უკვე არსებული ფუნქციონალით ჰოთსვაპი საკმაოდ მარტივი რაღაც არის. დამხმარე სერვერი ჩანაცვლდება სათადარიგო სერვერით, მთავარ სერვერზე მთლიანი კონტენტი დაარქივდება tar პროგრამით და დაკომპრესირდება gzip კომპრესირებით. მიღებული ფაილი გადაკოპირდება დამხმარე (ყოფილი სათადარიგო) სერვერზე ამოარქივდება და ორივე სერვერზე წაიშლება ეს დროებითი ფაილი. ძველი დამხმარე სერვერი ახლა იქნება სათადარიგოდ შენახული და თუ ჩაირთვება შესაძლებელი იქნება კიდევ ერთხელ ჩანაცვლება საჭიროების შემთხვევაში.

## cache
პროგრამას სისწრაფისთვის შეუძლია ქეშირება. კონფიგურაციის ფაილში გაწერილი ზომის ქეშს გამოყოფს და ინახავს ყველაფერს, რაც სერვერდიდან იკითხება. ქეში ფაილს ინახავს ბლოკებად და მოთხოვნილ მონაცემებს ქეშში ეძებს მოთხოვნილი მონაცემის ფაილში ინდექსის საშუალებით გამოთვლილი ბლოკის ინდექსის მიხედვით. კლიენტს საშუალება ეძლევა, აირჩიოს სამი გამოძევების ალგორითმიდან (lru, mru, second chance) ერთ-ერთი კონფიგურაციის ფაილის გამოყენებით. არაიმპლემენტირებული გამოძევების ალგორითმის მოთხოვნის შემთხვევაში იყენებს დეფოლტ ალგორითმს (second chance).
