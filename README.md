# Network Raid

### გიორგი გველესიანი
<br>

## ზოგადი იდეა
პროექტი არის დისტრიბუციული ფაილური სისტემის იმპლემენტაცია ლინუქსის API-ს გამოყენებით. კლიენტს ეძლევა შესაძლებლობა, თავის სისტემაში რამდენიმე დირექტორიაზე დაამაუნთოს სერვერები. ამის პლიუსი არის დიდ დრაივზე წვდომა ნებისმიერი ადგილიდან და უსაფრთხოება, რადგან სერვერები კლიენტის მიერ არჩეული რეიდის მიხედვით იცავენ დატას მთლიანობას. სამაგიეროდ დრაივის ჯიბით ტარებისგან განსხვავებით უინტერნეტოდ სერვერთან წვდომა ვერ მოხდება და იდეალური ინტერნეტის შემთხვევაშიც იქნება ოვერჰედი.

## გამოყენება
პროექტის გაშვებამდე საჭიროა რამდნიმე ბიბლიოთეკის გადმოწერა Advanced Package Tool-ის გამოყენებით:
* libssl-dev
* pkg-config 
* libfuse-dev
* attr

ბრძანებით: `sudo apt install pkg-config libfuse-dev libssl-dev attr`

საჭირო ბიბლიოთეკების დაყენების შემდეგ პროგრამა კომპილირდება `make` ბრძანებით, სუფთავდება `make clean`-ით (და ფაილში კონფიგურაციის ფაილის მისამართის შეცვლის შემდეგ მაუნთდება `make m` -ით). პროგრამას სჭირდება კონფიგურაციის ფაილი, რომელშიც გაწერილი იქნება ფუნქციონირებისთვის საჭირო ინფორმაცია (კლიენტის მოთხოვნები)

### კლიენტის გაშვება (დამაუნთება)
`./client CONFIG_PATH`

### სერვერის გაშვება 
`./server IP PORT DISK_PATH`

## კომფორტის შემქმნელი feature-ები
### კონფიგურაცია
კონფიგურაციის ფაილს პარსავს პარსერ პროგრამა და აბრუნებს სტრუქტურას `storage`. კონფიგურაციის ფაილი აუცილებელია, პირველ ოთხ ხაზზე შეიცავდეს errorlog, cache_size, cache_replacment და timeout ვლეებს. ხაზი დასრულებულად ჩაითბლება მხოლოს მაშინ, როცა ეწერება `\n`. ხაზის ბოლოს სფეისები ჩსითვლებიან ვალიდურ სიმბოლოებად და პროგრამა ისე არ მოიქცევა, როგორც კლიენტს უნდა. ამ ოთხი ხაზის შემდეგ უნდა იყოს ცარიელი ხაზით გამოყოფილი ხუთი ხაზისგან შემდგარი საწყობის (storage) ან საწყობების (ერთმანეთისგან ცარიელი ხაზით გამოყოფილი) ინფორმაცია.  თანმიმდევრობის არევის, ზედმეტი სფეისების და ნიუ ლაინების შემთხვევაში პროგრამა არ იმუშავებს.

### ლოგირება
ლოგირება ხდება ყველა სისტემური ბრძანების, გარდა `getattr`-ისა, რადგან ის ძალიან ბევრჯერ გამოიძახება და ლოგის წაკითხვას ართულებს. გამზადებული ბრძანება `client.c` ფაილში არის დაკომენტარებული და საჭიროების შემთხვევაში შეიძლება ამის ჩართვაც, მაგრამ არ ვურჩევ არავის. სისტემური ბრძანებების გარდა ხდება ისეთი მნისვნელოვანი მნისვნელოვანი მომენტების ლოგირება, როგორიცაა სერვერთან კავშირის სთეითი, დაზიანებული ფაილის აღმოჩენა და etc.

## რეიდ 1
იმპლემენტირებული სისქოლები არიან open, read, write, release, rename, unlink, rmdir, mkdir, readdir, getattr, mknod, utimens, truncate.

სერვერებს პირობითად ჰქვიათ primary და secondary (შემდგომ მთავარი და დამხმარე). მთავარი სერვერი მუშაობს ყველა სისტემური ბრძანების დროს, ხოლო დამხმარე (ოფტიმალურობისთვის) მხოლოდ მაშინ, როცა მისი სთეითის შეცვლაა საჭირო. ინფორმაციის წამოღება დამხმარე სერვერიდან არ ხდება. ჩაწერა ხდება `stable storage` მექანიზმით. დაზიანებული ან არარსებული ფაილის აღმოჩენა ხდება `open` -ის დროს. გახსნის დროს მოწმდება ჰეშები (SHA1, რომელიც შექმნის და ჩაწერის დროს გამოითვლება და ინახება). თუ ჰეში ფაილის კონტენტს არ დაემთხვევა, სერვერი აგზავნის HASH_ERROR-ს და კლიენტი მეორე სერვერიდან უგზავნის დატას. თუ ფაილი არ არსებობს (სერვერი დროებით გათიშული იყო როცა შეიქმნა) სერვერზე ხდება ერორი და დაბრუნებული ერნო არის ENOENT, ამ შემთხვევაშიც კლიენტი უკოპირებს მეორე სერვერიდან. თუ ორივე ფაილი უშეცდომოდ გაიხსნა, მაგრამ დაბრუნებული ჰეშები არ ემთხვევა განახლების დრო რომელსაც მეტი აქვს იმ ფაილს ვიღებთ სწორ ფაილად და მეორეს ვანაცვლებთ. ეს აგვარებს როგორც stable storage ექანიზმით გათვალისწინებულ პრობლემას, ასევე სერვერი თუ საერთოდ გათიშული იყო აფდეითის დროს და ვერ მოხდა ფაილის კონტენტის განახლება. 


## timeout and hotswap
### timeout
 სერვერთან კავშირი მოწმდება სერვერზე მარტივი შეტყობინების გაგზავნით (ping-ის გამარტივებული ვარიანტი). სერვერს ეგზავნება სტანდარტული სისქოლის ჰედერი და უკან აბრუნებს 1-ს. თუ ქონექშენი გაფუჭებულია, კლიენტს არაფერი დაუბრუნდება და სერვერს დაკარგულად გამოაცხადებს. თუ ეს მთავარი სერვერი იყო, მაშინ დამხმარე გამოცხადდება მთავარ სერვერად. პერიოდულად ისევ მოწმდება სერვერთან კავშირის აღდგენა თუ არის შესაძლებელი. კონფიგში მოცემული დროის გასვლის შემდეგ თუ ვერ მოხდა დაკავშირდება, იწყება hotswap

 ### hotswap
კვე არსებული ფუნქციონალით ჰოთსვაპი საკმაოდ მარტივი რაღაც არის. დამხმარე სერვერი ჩანაცვლდება სათადარიგო სერვერით, მთავარ სერვერზე მთლიანი კონტენტი დაარქივდება tar პროგრამით და დაკომპრესირდება gzip კომპრესირებით. მიღებული ფაილი გადაკოპირდება დამხმარე (ყოფილი სათადარიგო) სერვერზე ამოარქივდება და ორივე სერვერზე წაიშლება ეს დროებითი ფაილი. ძველი დამხმარე სერვერი ახლა იქნება სათადარიგოდ შენახული და თუ ჩაირთვება შესაძლებელი იქნება კიდევ ერთხელ ჩანაცვლება საჭიროების შემთხვევაში.